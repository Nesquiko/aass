// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	externalRef0 "github.com/Nesquiko/aass/common/server/api"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/nullable"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for AppointmentDecisionAction.
const (
	Accept AppointmentDecisionAction = "accept"
	Reject AppointmentDecisionAction = "reject"
)

// Defines values for AppointmentStatus.
const (
	Cancelled AppointmentStatus = "cancelled"
	Completed AppointmentStatus = "completed"
	Denied    AppointmentStatus = "denied"
	Requested AppointmentStatus = "requested"
	Scheduled AppointmentStatus = "scheduled"
)

// Defines values for AppointmentType.
const (
	AnnualPhysical  AppointmentType = "annual_physical"
	Consultation    AppointmentType = "consultation"
	FollowUp        AppointmentType = "follow_up"
	NewPatient      AppointmentType = "new_patient"
	Procedure       AppointmentType = "procedure"
	RegularCheck    AppointmentType = "regular_check"
	SpecialistVisit AppointmentType = "specialist_visit"
	UrgentCare      AppointmentType = "urgent_care"
	Vaccination     AppointmentType = "vaccination"
)

// Defines values for SpecializationEnum.
const (
	Cardiologist        SpecializationEnum = "cardiologist"
	Dermatologist       SpecializationEnum = "dermatologist"
	Diagnostician       SpecializationEnum = "diagnostician"
	Endocrinologist     SpecializationEnum = "endocrinologist"
	Gastroenterologist  SpecializationEnum = "gastroenterologist"
	GeneralPractitioner SpecializationEnum = "general_practitioner"
	Neurologist         SpecializationEnum = "neurologist"
	Oncologist          SpecializationEnum = "oncologist"
	Orthopedist         SpecializationEnum = "orthopedist"
	Other               SpecializationEnum = "other"
	Pediatrician        SpecializationEnum = "pediatrician"
	Psychiatrist        SpecializationEnum = "psychiatrist"
	Radiologist         SpecializationEnum = "radiologist"
	Surgeon             SpecializationEnum = "surgeon"
	Urologist           SpecializationEnum = "urologist"
)

// Defines values for TimeSlotStatus.
const (
	Available   TimeSlotStatus = "available"
	Unavailable TimeSlotStatus = "unavailable"
)

// Defines values for UserRole.
const (
	UserRoleDoctor  UserRole = "doctor"
	UserRolePatient UserRole = "patient"
)

// Appointment Contains information about an appointment.
type Appointment struct {
	AppointmentDateTime time.Time `json:"appointmentDateTime"`
	CanceledBy          *UserRole `json:"canceledBy,omitempty"`
	CancellationReason  *string   `json:"cancellationReason,omitempty"`

	// Condition Basic info about a patient's condition.
	Condition    *ConditionDisplay `json:"condition,omitempty"`
	DenialReason *string           `json:"denialReason,omitempty"`
	Doctor       Doctor            `json:"doctor"`

	// Equipment List of required equipment for the appointment.
	Equipment *[]Equipment `json:"equipment,omitempty"`

	// Facilities List of required facilities for the appointment.
	Facilities *[]Facility        `json:"facilities,omitempty"`
	Id         openapi_types.UUID `json:"id"`

	// Medicine List of required medicine for the appointment.
	Medicine      *[]Medicine            `json:"medicine,omitempty"`
	Patient       Patient                `json:"patient"`
	Prescriptions *[]PrescriptionDisplay `json:"prescriptions,omitempty"`
	Reason        *string                `json:"reason,omitempty"`

	// Status The current status of the appointment.
	Status AppointmentStatus `json:"status"`

	// Type The type of the appointment.
	Type AppointmentType `json:"type"`
}

// AppointmentCancellation Data required to cancel an appointment.
type AppointmentCancellation struct {
	By UserRole `json:"by"`

	// Reason Optional reason provided for the cancellation.
	Reason *string `json:"reason,omitempty"`
}

// AppointmentDecision Data required for staff to accept or reject an appointment request.
type AppointmentDecision struct {
	// Action The decision action to take on the appointment request.
	Action    AppointmentDecisionAction `json:"action"`
	Equipment *openapi_types.UUID       `json:"equipment,omitempty"`
	Facility  *openapi_types.UUID       `json:"facility,omitempty"`
	Medicine  *openapi_types.UUID       `json:"medicine,omitempty"`

	// Reason Required reason if the action is 'reject'. Optional otherwise.
	Reason *string `json:"reason,omitempty"`
}

// AppointmentDecisionAction The decision action to take on the appointment request.
type AppointmentDecisionAction string

// AppointmentDisplay Represents an appointment view.
type AppointmentDisplay struct {
	// AppointmentDateTime The date time of the appointment.
	AppointmentDateTime time.Time `json:"appointmentDateTime"`
	DoctorName          string    `json:"doctorName"`

	// Id Unique identifier for the appointment.
	Id          openapi_types.UUID `json:"id"`
	PatientName string             `json:"patientName"`

	// Status The current status of the appointment.
	Status AppointmentStatus `json:"status"`

	// Type The type of the appointment.
	Type AppointmentType `json:"type"`
}

// AppointmentReschedule Data required for a patient to reschedule their appointment.
type AppointmentReschedule struct {
	NewAppointmentDateTime time.Time `json:"newAppointmentDateTime"`

	// Reason Optional reason for rescheduling provided by the patient.
	Reason *string `json:"reason,omitempty"`
}

// AppointmentResourceUpdate Specifies resources to add or update for an appointment. Fields are optional; include only those to change. Use null to remove an existing resource association.
type AppointmentResourceUpdate struct {
	// EquipmentId The equipment ID to associate, or null to remove association.
	EquipmentId nullable.Nullable[openapi_types.UUID] `json:"equipmentId,omitempty"`

	// FacilityId The facility ID to associate, or null to remove association.
	FacilityId nullable.Nullable[openapi_types.UUID] `json:"facilityId,omitempty"`

	// MedicineId The medicine ID to associate, or null to remove association.
	MedicineId nullable.Nullable[openapi_types.UUID] `json:"medicineId,omitempty"`
}

// AppointmentStatus The current status of the appointment.
type AppointmentStatus string

// AppointmentType The type of the appointment.
type AppointmentType string

// Appointments defines model for Appointments.
type Appointments struct {
	Appointments *[]AppointmentDisplay `json:"appointments,omitempty"`
}

// ConditionDisplay Basic info about a patient's condition.
type ConditionDisplay struct {
	AppointmentsIds *[]openapi_types.UUID `json:"appointmentsIds,omitempty"`
	End             *time.Time            `json:"end,omitempty"`
	Id              *openapi_types.UUID   `json:"id,omitempty"`
	Name            string                `json:"name"`
	Start           time.Time             `json:"start"`
}

// Doctor defines model for Doctor.
type Doctor struct {
	Email     openapi_types.Email `json:"email"`
	FirstName string              `json:"firstName"`
	Id        openapi_types.UUID  `json:"id"`
	LastName  string              `json:"lastName"`
	Role      UserRole            `json:"role"`

	// Specialization Medical specialization of a doctor.
	Specialization SpecializationEnum `json:"specialization"`
}

// Equipment Represents a required equipment resource.
type Equipment struct {
	// Id Unique identifier for the equipment.
	Id openapi_types.UUID `json:"id"`

	// Name Name of the equipment.
	Name string `json:"name"`
}

// Facility Represents a required facility resource.
type Facility struct {
	// Id Unique identifier for the facility.
	Id openapi_types.UUID `json:"id"`

	// Name Name of the facility.
	Name string `json:"name"`
}

// Medicine Represents a required medicine resource.
type Medicine struct {
	// Id Unique identifier for the medicine.
	Id openapi_types.UUID `json:"id"`

	// Name Name of the medicine.
	Name string `json:"name"`
}

// NewAppointmentRequest defines model for NewAppointmentRequest.
type NewAppointmentRequest struct {
	AppointmentDateTime time.Time           `json:"appointmentDateTime"`
	ConditionId         *openapi_types.UUID `json:"conditionId,omitempty"`
	DoctorId            openapi_types.UUID  `json:"doctorId"`
	PatientId           openapi_types.UUID  `json:"patientId"`

	// Reason Reason for the appointment provided by the patient.
	Reason *string `json:"reason,omitempty"`

	// Type The type of the appointment.
	Type *AppointmentType `json:"type,omitempty"`
}

// Patient defines model for Patient.
type Patient struct {
	Email     openapi_types.Email `json:"email"`
	FirstName string              `json:"firstName"`
	Id        openapi_types.UUID  `json:"id"`
	LastName  string              `json:"lastName"`
	Role      UserRole            `json:"role"`
}

// PrescriptionDisplay Basic info about a patient's condition.
type PrescriptionDisplay struct {
	AppointmentId *openapi_types.UUID `json:"appointmentId,omitempty"`
	End           time.Time           `json:"end"`
	Id            *openapi_types.UUID `json:"id,omitempty"`
	Name          string              `json:"name"`
	Start         time.Time           `json:"start"`
}

// SpecializationEnum Medical specialization of a doctor.
type SpecializationEnum string

// TimeSlot Represents a single time slot for a doctor on a specific day.
type TimeSlot struct {
	// Status Indicates whether the time slot is available or not.
	Status TimeSlotStatus `json:"status"`

	// Time The time of the slot (HH:MM format, 24-hour clock).
	Time string `json:"time"`
}

// TimeSlotStatus Indicates whether the time slot is available or not.
type TimeSlotStatus string

// UserRole defines model for UserRole.
type UserRole string

// AppointmentId defines model for appointmentId.
type AppointmentId = openapi_types.UUID

// ConditionId defines model for conditionId.
type ConditionId = openapi_types.UUID

// Date defines model for date.
type Date = openapi_types.Date

// DoctorId defines model for doctorId.
type DoctorId = openapi_types.UUID

// From defines model for from.
type From = openapi_types.Date

// PatientId defines model for patientId.
type PatientId = openapi_types.UUID

// To defines model for to.
type To = openapi_types.Date

// DoctorTimeslots defines model for DoctorTimeslots.
type DoctorTimeslots struct {
	Slots []TimeSlot `json:"slots"`
}

// DoctorsCalendarParams defines parameters for DoctorsCalendar.
type DoctorsCalendarParams struct {
	// From The specific day form which to retrieve resources.
	From From `form:"from" json:"from"`

	// To The specific day to which to retrieve resources.
	To *To `form:"to,omitempty" json:"to,omitempty"`
}

// PatientsCalendarParams defines parameters for PatientsCalendar.
type PatientsCalendarParams struct {
	// From The specific day form which to retrieve resources.
	From From `form:"from" json:"from"`

	// To The specific day to which to retrieve resources.
	To *To `form:"to,omitempty" json:"to,omitempty"`
}

// DoctorsTimeslotsParams defines parameters for DoctorsTimeslots.
type DoctorsTimeslotsParams struct {
	// Date The specific day for which to retrieve timeslots (YYYY-MM-DD format).
	Date Date `form:"date" json:"date"`
}

// RequestAppointmentJSONRequestBody defines body for RequestAppointment for application/json ContentType.
type RequestAppointmentJSONRequestBody = NewAppointmentRequest

// CancelAppointmentJSONRequestBody defines body for CancelAppointment for application/json ContentType.
type CancelAppointmentJSONRequestBody = AppointmentCancellation

// RescheduleAppointmentJSONRequestBody defines body for RescheduleAppointment for application/json ContentType.
type RescheduleAppointmentJSONRequestBody = AppointmentReschedule

// DecideAppointmentJSONRequestBody defines body for DecideAppointment for application/json ContentType.
type DecideAppointmentJSONRequestBody = AppointmentDecision

// UpdateAppointmentResourcesJSONRequestBody defines body for UpdateAppointmentResources for application/json ContentType.
type UpdateAppointmentResourcesJSONRequestBody = AppointmentResourceUpdate

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Patient creates an appointment request
	// (POST /appointments)
	RequestAppointment(w http.ResponseWriter, r *http.Request)
	// Get appointments by condition ID
	// (GET /appointments/condition/{conditionId})
	AppointmentsByConditionId(w http.ResponseWriter, r *http.Request, conditionId ConditionId)
	// Get doctors's calendar
	// (GET /appointments/doctor/{doctorId})
	DoctorsCalendar(w http.ResponseWriter, r *http.Request, doctorId DoctorId, params DoctorsCalendarParams)
	// Get patient's calendar
	// (GET /appointments/patient/{patientId})
	PatientsCalendar(w http.ResponseWriter, r *http.Request, patientId PatientId, params PatientsCalendarParams)
	// Cancel an appointment
	// (DELETE /appointments/{appointmentId})
	CancelAppointment(w http.ResponseWriter, r *http.Request, appointmentId AppointmentId)
	// Get appointment details
	// (GET /appointments/{appointmentId})
	AppointmentById(w http.ResponseWriter, r *http.Request, appointmentId AppointmentId)
	// Reschedule an appointment
	// (PATCH /appointments/{appointmentId})
	RescheduleAppointment(w http.ResponseWriter, r *http.Request, appointmentId AppointmentId)
	// Decide appointment's status
	// (POST /appointments/{appointmentId})
	DecideAppointment(w http.ResponseWriter, r *http.Request, appointmentId AppointmentId)
	// Add or update resources for an appointment
	// (PATCH /appointments/{appointmentId}/resources)
	UpdateAppointmentResources(w http.ResponseWriter, r *http.Request, appointmentId AppointmentId)
	// Get doctor's timeslots for a specific date
	// (GET /timeslots/{doctorId})
	DoctorsTimeslots(w http.ResponseWriter, r *http.Request, doctorId DoctorId, params DoctorsTimeslotsParams)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Patient creates an appointment request
// (POST /appointments)
func (_ Unimplemented) RequestAppointment(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get appointments by condition ID
// (GET /appointments/condition/{conditionId})
func (_ Unimplemented) AppointmentsByConditionId(w http.ResponseWriter, r *http.Request, conditionId ConditionId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get doctors's calendar
// (GET /appointments/doctor/{doctorId})
func (_ Unimplemented) DoctorsCalendar(w http.ResponseWriter, r *http.Request, doctorId DoctorId, params DoctorsCalendarParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get patient's calendar
// (GET /appointments/patient/{patientId})
func (_ Unimplemented) PatientsCalendar(w http.ResponseWriter, r *http.Request, patientId PatientId, params PatientsCalendarParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Cancel an appointment
// (DELETE /appointments/{appointmentId})
func (_ Unimplemented) CancelAppointment(w http.ResponseWriter, r *http.Request, appointmentId AppointmentId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get appointment details
// (GET /appointments/{appointmentId})
func (_ Unimplemented) AppointmentById(w http.ResponseWriter, r *http.Request, appointmentId AppointmentId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Reschedule an appointment
// (PATCH /appointments/{appointmentId})
func (_ Unimplemented) RescheduleAppointment(w http.ResponseWriter, r *http.Request, appointmentId AppointmentId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Decide appointment's status
// (POST /appointments/{appointmentId})
func (_ Unimplemented) DecideAppointment(w http.ResponseWriter, r *http.Request, appointmentId AppointmentId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Add or update resources for an appointment
// (PATCH /appointments/{appointmentId}/resources)
func (_ Unimplemented) UpdateAppointmentResources(w http.ResponseWriter, r *http.Request, appointmentId AppointmentId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get doctor's timeslots for a specific date
// (GET /timeslots/{doctorId})
func (_ Unimplemented) DoctorsTimeslots(w http.ResponseWriter, r *http.Request, doctorId DoctorId, params DoctorsTimeslotsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// RequestAppointment operation middleware
func (siw *ServerInterfaceWrapper) RequestAppointment(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RequestAppointment(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AppointmentsByConditionId operation middleware
func (siw *ServerInterfaceWrapper) AppointmentsByConditionId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "conditionId" -------------
	var conditionId ConditionId

	err = runtime.BindStyledParameterWithOptions("simple", "conditionId", chi.URLParam(r, "conditionId"), &conditionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "conditionId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AppointmentsByConditionId(w, r, conditionId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DoctorsCalendar operation middleware
func (siw *ServerInterfaceWrapper) DoctorsCalendar(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "doctorId" -------------
	var doctorId DoctorId

	err = runtime.BindStyledParameterWithOptions("simple", "doctorId", chi.URLParam(r, "doctorId"), &doctorId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "doctorId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DoctorsCalendarParams

	// ------------- Required query parameter "from" -------------

	if paramValue := r.URL.Query().Get("from"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "from"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "from", r.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from", Err: err})
		return
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", r.URL.Query(), &params.To)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "to", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DoctorsCalendar(w, r, doctorId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PatientsCalendar operation middleware
func (siw *ServerInterfaceWrapper) PatientsCalendar(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "patientId" -------------
	var patientId PatientId

	err = runtime.BindStyledParameterWithOptions("simple", "patientId", chi.URLParam(r, "patientId"), &patientId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "patientId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatientsCalendarParams

	// ------------- Required query parameter "from" -------------

	if paramValue := r.URL.Query().Get("from"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "from"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "from", r.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from", Err: err})
		return
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", r.URL.Query(), &params.To)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "to", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatientsCalendar(w, r, patientId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CancelAppointment operation middleware
func (siw *ServerInterfaceWrapper) CancelAppointment(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "appointmentId" -------------
	var appointmentId AppointmentId

	err = runtime.BindStyledParameterWithOptions("simple", "appointmentId", chi.URLParam(r, "appointmentId"), &appointmentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "appointmentId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CancelAppointment(w, r, appointmentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AppointmentById operation middleware
func (siw *ServerInterfaceWrapper) AppointmentById(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "appointmentId" -------------
	var appointmentId AppointmentId

	err = runtime.BindStyledParameterWithOptions("simple", "appointmentId", chi.URLParam(r, "appointmentId"), &appointmentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "appointmentId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AppointmentById(w, r, appointmentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RescheduleAppointment operation middleware
func (siw *ServerInterfaceWrapper) RescheduleAppointment(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "appointmentId" -------------
	var appointmentId AppointmentId

	err = runtime.BindStyledParameterWithOptions("simple", "appointmentId", chi.URLParam(r, "appointmentId"), &appointmentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "appointmentId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RescheduleAppointment(w, r, appointmentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DecideAppointment operation middleware
func (siw *ServerInterfaceWrapper) DecideAppointment(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "appointmentId" -------------
	var appointmentId AppointmentId

	err = runtime.BindStyledParameterWithOptions("simple", "appointmentId", chi.URLParam(r, "appointmentId"), &appointmentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "appointmentId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DecideAppointment(w, r, appointmentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateAppointmentResources operation middleware
func (siw *ServerInterfaceWrapper) UpdateAppointmentResources(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "appointmentId" -------------
	var appointmentId AppointmentId

	err = runtime.BindStyledParameterWithOptions("simple", "appointmentId", chi.URLParam(r, "appointmentId"), &appointmentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "appointmentId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateAppointmentResources(w, r, appointmentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DoctorsTimeslots operation middleware
func (siw *ServerInterfaceWrapper) DoctorsTimeslots(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "doctorId" -------------
	var doctorId DoctorId

	err = runtime.BindStyledParameterWithOptions("simple", "doctorId", chi.URLParam(r, "doctorId"), &doctorId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "doctorId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DoctorsTimeslotsParams

	// ------------- Required query parameter "date" -------------

	if paramValue := r.URL.Query().Get("date"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "date"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "date", r.URL.Query(), &params.Date)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DoctorsTimeslots(w, r, doctorId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/appointments", wrapper.RequestAppointment)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/appointments/condition/{conditionId}", wrapper.AppointmentsByConditionId)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/appointments/doctor/{doctorId}", wrapper.DoctorsCalendar)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/appointments/patient/{patientId}", wrapper.PatientsCalendar)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/appointments/{appointmentId}", wrapper.CancelAppointment)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/appointments/{appointmentId}", wrapper.AppointmentById)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/appointments/{appointmentId}", wrapper.RescheduleAppointment)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/appointments/{appointmentId}", wrapper.DecideAppointment)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/appointments/{appointmentId}/resources", wrapper.UpdateAppointmentResources)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/timeslots/{doctorId}", wrapper.DoctorsTimeslots)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/9xbeXPbNhb/KhhuZ5LMihZ9xYn2L8dKWs+s24ydTJtNvR4IfJLQQAADgHZVr7/7DgAe",
	"oAhKVOzUaf+zLBzv+L0TT7cREYtMcOBaRaPbKMMSL0CDtJ9wlgnK9QK4Pk3NP1JQRNJMU8GjUfRuDijn",
	"9HMOiKbANZ1SkOjp+/en42dITJGeA/KO2IkGEfyOFxmDaBSlB3A4fY6P4skL8jJOdvf244PD50fxi5cJ",
	"npAUprt7+9EgouaiDOt5NIg4XpidTaoGkYTPOZWQRiMtcxhEisxhgQ25UyEXWEejKM+pWamXmTlAaUn5",
	"LLq7G0RE8JQadr6Uv+qAJnckSXf1bsLj3bRmDE9iw5jh1fwnzJ1P0f14S7GGMFMqA0KnlKAUL9FUSHQz",
	"p2SOtEAStKRwDUjTBSgmtEJPP3z48CE+O4vHY+QufdbkdS/ZO4iTo3j3sOTocw5yWbNkCenFS7EywIsg",
	"WsgvVZLb3aR6skf2DQZjC8IXL5Pd2Kglfn5UIzCsoYqW+6lnKsWin3oWAf1IUCKXBNSWurC33k8XGdb0",
	"Hh6h2P5Q2qipuZ86tOihDC0eUBVaRNsI/s7wpzLBFVjnPLYwfFfaqfkXEVwD14XrZpRgw8jwN2W4ufXu",
	"yqTIQGrqTqr2Uw0L+8d3EqbRKPrHsI4OQ7dbDc2NF0zo6K6iEUuJl5GjsNTAx+LYy2qVmPwGRDtOmnK+",
	"yAkBpaY5Y8tKrqlFC6NKW+TQBSB74k5k/fZiIfiVAnkN8gpn9Mr9JxYZcPPxlGuQHLMLu+K1lEKeF9Jb",
	"I6lMigmDxT9LiVXaNDtSwwQtzt1xV++AOTkyDGlMWTSKjjnK+ScubjhyS5BdggQhuTSSGURKY52raHSY",
	"JINIU23hUhLc2GVYrbW2TisbBWJFMHZUBlRwzFfo3EEX4KHf0YyMFGzEcPwaZVQkWuQc18G5bU8ngmtM",
	"uUKUO7RTwRGeiFwjzFdThSZGvS/HWIMBYctoYgOStuUMIoI5AQbpq+UmMb5XIM8Fg3oXs1SeAy4g0T68",
	"DNibzj4pF46pypgxGKMETjFbc7oLNpuOdr7ArDf2l4Wl/+/ClEobRdVaq9FAttbLH7yubmw5hEE0xYQy",
	"WipxAz314nsR9MYdswzRQ9Me0WAQLSClhHLoQXS59F4kn5X3BUguAtymI94Wy8wOWZPc36+/9XZ5CF0l",
	"R3ZjtfRr6+/xPMSF21Dd0nvjO7N8Nd5YVYb8RHF8RWAt08q+2lFq4LuyE88VtDExxhrXgNACOc+x0adN",
	"tnJHteCbt/9k/8AMuQUok+KapsacCkD6fqyZorwBYJTP0AS0BjlAXCAm+Awk4lDEXyK4ypmuNrcTJ18F",
	"k+UmSY6BUNVDioZ4pfF0auSJCYFMIyGRBHPmimTtLlChqEHCGjOJXVpQgtwic4/GnwCZP5tm7J8PPF8Y",
	"Th1JNue0XF76cq2+bJlIwz1vdEPT0pNt67M2Lu4C03kp/wJMtKjinYioQk8cv092UIU7oecgb6iCJrhc",
	"TEIGymnOLJKmjBK9g94ywAoQmQuhAGFuD7AZ3maEFRrdhLLCfwX4M87R2Ngqhq4p3PROOwJowtoVzR2N",
	"j36JivNGP2J3S+trGii53rfKrY5AtHXrZSOICi/aSe63Gw88OTfZ8GKEJWEDzs6hhHcff4bL2teVj5Vl",
	"6DlQuT5UcLg5vk8G3Dd4TK2PLSgzoaGKJpNld/X+s5CfKvtGWArVw5I7WNoscVtsv8/C7a0LV7CAqsty",
	"G0HS1ISP3O5yymgGZ/SGAksVwhKQKITyL0Q5YXlqYgIz7Bt3ZcL7HPMZ7KD3ChDPGXPqXIhr48wQ/E6V",
	"NqIrCUBYKUFoFUKbmq0iQlc/pc7ST8eWleI0GBiOVu9vXrVqwmY1nhiduQZJZ8TpIqb8/s+gpQxoXbRU",
	"mfdXp+VuPSYvKj/XJtIW01yX9XNHV7xIKoo8wzYJiqzNNQwKT2H/L4zRuTWmeoS0mXv4a1siXXWZQZLN",
	"ro2EznKG5RWZA/lk5Ac3V3VOPRWMiZurPDP+l/Mcs6tsvlSUYGYZqDPKaBBdY0IoLz/lcgZcXxEswVkK",
	"gTS3f9tOBGZU6atrqqj2HEWQP9Xuc+GVb3uVRYGsItT4auGjVe23ZP0KK0psK6TsgZTe9Ylqvit0s3Ga",
	"NjnZGLNXyzngaf8oEq6eJeD0J86WnYbM1yQIUve9PhTdeRWzpQ5GjnHVPsGM/TSNRh/7VtGtJmmBvz9w",
	"n17PRWP1a2M2rfZo88A29Zd3g+h1dzvHT2VDPZ0y/LQBtF0aWZ3YjPnwOYuTZC+eHsHzOD0kB/FkH+/1",
	"SRtLODQJMOlX6XU6rnzPtMRK5DxFZ5jMjev/5fv4cAuohCDyxiuy+ki4CoEPJeDywCazU0ziJNmN8d5k",
	"PyYH6WEMz6dHDyPf8I1n56foIqca0Kt7ivSss30WFmkVyR9KpOWBTQYXkMZJsh+/xC8m8RF5nsaHcDB9",
	"GJGGbzzmGJSeg6YE/fLhP/cU64+NjPncJQtrw9wXtMqbD+IbJeM/zPYtGHuu7u5RVKXKaqOmV7VSdr1y",
	"fgOMDdAMOEjMkE1m4jyzzS9Id7rD5/3qUv/F0ntLxj2Lobd1P3ilkljYFyhPsu4/oTSfSqU3tBk26ofh",
	"NWdIwaB/dzNkBjWN3lWDiid7QVA+gT7218i9eqL4b5RgOWZCMg+kOy2R26CAGWrmPcZ/Yn9Ao6gwlKkE",
	"bEkww0pLAVyDFEzMqDKEZJBSrCUlFJs1KcUzLpQuPwNPBZGU1xsKI7/KJCbaKhekrbJkSutVKRgx1Z85",
	"5N6lghPvg9RzYchw9KglmVuK7EeJ/VMbZ+g5yGbFtkp8S4vVi/v6cKoonzGoX8qLnpOTLRLcLPGGGdrg",
	"Vh117Ck3mtOg0M0cXK927t9DFcLXmNoK2tbeotkqL78zouD1p2bL3FvU9rqdbVe/42ppefrDD6Ozs2JQ",
	"aYD2DuK5yCUiTJBPK3NLycvRfuL6fxqkOfG/Tz8mu5e//pr+b+9jEu9fPhs9/ZjEh+Y/z77baDCFVRVS",
	"DJlJ5fCMty6ks+Ypyo/KW7zuGzeVOgeG2VtPw857rPTLNOapMYI/TPFgJwCKp3309PzNCXp5cHj0rA0V",
	"Nw0Req+uaFjTDq68EeXeKwnlGmYgncI1C53fkri2gLHUeK3bgojw6Ilx+uZoRgkU0yDFQM7Z6TtrrSwa",
	"RXOtMzUaDo2Ai5xUyNmw2KSGZm1NqHVuJ5ihM0qkuAB5TQkodPz2NBpE1yDdi1e0u5PsJGZbobZoFO3v",
	"JDsHDoRzK5vhapciEy7JM+LHZWYWFdmfP24xKPtHr0S63GocaF2QDiedgQmSVkjteEVrzWmtDjbtJbsP",
	"Rr0vn9DUi0eeag4hFZ04O210mCRdF1WUD+81kmSnaPLFAstlNCpTPEQkWLcbfu40loNnyhhCo+91aQ5r",
	"wGhYZTTDWy/BvzNMzSAYV9wMlgkr5QSWf2DdbE3RDdVzP7RUF3iFmXEgTfz6FL9anjSGXv0h5I5+Tb1k",
	"6Fcsd5ctLCVfA0tqiym2tXJbGSF+BKx9D7pJ4mTpqfB0vAXKXAAb3pZFjY+vpvZdW06dYAYm+myt86ps",
	"uhtsXGsnXnus0+Jx4XMOOpcc0iJhe6KaanHJ3IxeA3dZTwaSivSxIOOIVKZaqpVYAqVQbwgjRbozvK2q",
	"4G6UFG7wy2FSV9p/R5x4BWshoG8NJG0KPZCU2g2h5LZRZ9+5AMXAPfg2QeJGs5p50HYoadb0TrcPn0d1",
	"TZMFNVw1uIpXQMpn7ee4dt500I7knRlO9b74KFHnJDQh1x1qBmEH4a16tfyC1CGk+a9v1ZsS0Xq0+tGz",
	"gZKWdZrJsCbzUApZvkSr0g80ItoAYabKWQpl38dDr87uDb8av1stgso7/lL2700Nfbn1b66ikkevoh7X",
	"x9Ri3sLPlNX2yiyX66EBtd0vN96pkO2VcNoB8G7YjoHQ9K8F2WpsN6D+n4umYNFo3FY63yJwMSGZqdFK",
	"Hh4HwA4nvtSeKFTPJ/asylZyqWE1F+d+7xt03seMiRuFcJoa32M8kXHTpR8qn48H9UP9AGHuveOuaQ80",
	"QoBeZpRgK/GpBomoRnOs0ASAV4PD9pdIPC1n8ABN3aTeUuToBrsIoUBXVIJbb4jFbgzsGrO8GPpzm9EN",
	"ZawcDbOetTke1jRXN2oYmEFUf4lQ449LBmzg3bx+dkenY9UYpaubFI1ZyVN/LLJQhxZoAsWAZfpNhadK",
	"XU0bL0gNjksjV2Qp+0W5cDX5/rPdwXFjhrUeb21Ps673DtVPu8Odmh6dwOqxxxi996Tj/UqzUYoWkeF0",
	"bDcY8gNB0fUM6t+zfs2ekDOGjnx/vUJXf3b7qP2XJ8r7ob6TuPfE535G3O7JmMPsJU6uTYW/5qlFTPUS",
	"MrSCKo6p3kqaXYrLu/8HAAD//8k3CrlJQgAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../common/server/api/common-openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
