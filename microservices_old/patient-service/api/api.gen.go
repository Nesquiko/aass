// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/nullable"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for AppointmentStatus.
const (
	Cancelled AppointmentStatus = "cancelled"
	Completed AppointmentStatus = "completed"
	Denied    AppointmentStatus = "denied"
	Requested AppointmentStatus = "requested"
	Scheduled AppointmentStatus = "scheduled"
)

// Defines values for AppointmentType.
const (
	RegularCheck AppointmentType = "regular_check"
)

// Defines values for UserRole.
const (
	UserRolePatient UserRole = "patient"
)

// AppointmentDisplay Represents an appointment relevant to the patient's calendar.
type AppointmentDisplay struct {
	AppointmentDateTime time.Time          `json:"appointmentDateTime"`
	DoctorName          string             `json:"doctorName"`
	Id                  openapi_types.UUID `json:"id"`
	Status              AppointmentStatus  `json:"status"`
	Type                AppointmentType    `json:"type"`
}

// AppointmentStatus defines model for AppointmentStatus.
type AppointmentStatus string

// AppointmentType defines model for AppointmentType.
type AppointmentType string

// ConditionDisplay Represents a condition relevant to the patient's calendar.
type ConditionDisplay struct {
	End   nullable.Nullable[time.Time] `json:"end,omitempty"`
	Id    openapi_types.UUID           `json:"id"`
	Name  string                       `json:"name"`
	Start time.Time                    `json:"start"`
}

// ErrorDetail Standardized error details (RFC 9457).
type ErrorDetail struct {
	Code                 string                 `json:"code"`
	Detail               string                 `json:"detail"`
	Status               int                    `json:"status"`
	Title                string                 `json:"title"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// NewPatientRequest defines model for NewPatientRequest.
type NewPatientRequest struct {
	Email     openapi_types.Email `json:"email"`
	FirstName string              `json:"firstName"`
	LastName  string              `json:"lastName"`
}

// Patient defines model for Patient.
type Patient struct {
	Email     openapi_types.Email `json:"email"`
	FirstName string              `json:"firstName"`
	Id        *openapi_types.UUID `json:"id,omitempty"`
	LastName  string              `json:"lastName"`
	Role      *UserRole           `json:"role,omitempty"`
}

// PatientCalendarView Consolidated view of a patient's calendar items within a time range.
type PatientCalendarView struct {
	Appointments  *[]AppointmentDisplay  `json:"appointments,omitempty"`
	Conditions    *[]ConditionDisplay    `json:"conditions,omitempty"`
	Prescriptions *[]PrescriptionDisplay `json:"prescriptions,omitempty"`
}

// PrescriptionDisplay Represents a prescription relevant to the patient's calendar.
type PrescriptionDisplay struct {
	End   time.Time          `json:"end"`
	Id    openapi_types.UUID `json:"id"`
	Name  string             `json:"name"`
	Start time.Time          `json:"start"`
}

// UserRole defines model for UserRole.
type UserRole string

// From defines model for from.
type From = openapi_types.Date

// PatientId defines model for patientId.
type PatientId = openapi_types.UUID

// To defines model for to.
type To = openapi_types.Date

// InternalServerErrorResponse Standardized error details (RFC 9457).
type InternalServerErrorResponse = ErrorDetail

// GetPatientByEmailParams defines parameters for GetPatientByEmail.
type GetPatientByEmailParams struct {
	// Email The email address of the patient to retrieve.
	Email openapi_types.Email `form:"email" json:"email"`
}

// GetPatientCalendarParams defines parameters for GetPatientCalendar.
type GetPatientCalendarParams struct {
	// From The start date (inclusive) for retrieving calendar items (YYYY-MM-DD format).
	From From `form:"from" json:"from"`

	// To The end date (inclusive) for retrieving calendar items (YYYY-MM-DD format).
	To To `form:"to" json:"to"`
}

// CreatePatientJSONRequestBody defines body for CreatePatient for application/json ContentType.
type CreatePatientJSONRequestBody = NewPatientRequest

// Getter for additional properties for ErrorDetail. Returns the specified
// element and whether it was found
func (a ErrorDetail) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ErrorDetail
func (a *ErrorDetail) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ErrorDetail to handle AdditionalProperties
func (a *ErrorDetail) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["code"]; found {
		err = json.Unmarshal(raw, &a.Code)
		if err != nil {
			return fmt.Errorf("error reading 'code': %w", err)
		}
		delete(object, "code")
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &a.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
		delete(object, "detail")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ErrorDetail to handle AdditionalProperties
func (a ErrorDetail) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["code"], err = json.Marshal(a.Code)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'code': %w", err)
	}

	object["detail"], err = json.Marshal(a.Detail)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'detail': %w", err)
	}

	object["status"], err = json.Marshal(a.Status)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'status': %w", err)
	}

	object["title"], err = json.Marshal(a.Title)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'title': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Create a new patient profile
	// (POST /patients)
	CreatePatient(w http.ResponseWriter, r *http.Request)
	// Get patient by email address
	// (GET /patients/lookup/by-email)
	GetPatientByEmail(w http.ResponseWriter, r *http.Request, params GetPatientByEmailParams)
	// Get patient by ID
	// (GET /patients/{patientId})
	GetPatientById(w http.ResponseWriter, r *http.Request, patientId PatientId)
	// Get patient's calendar view
	// (GET /patients/{patientId}/calendar)
	GetPatientCalendar(w http.ResponseWriter, r *http.Request, patientId PatientId, params GetPatientCalendarParams)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Create a new patient profile
// (POST /patients)
func (_ Unimplemented) CreatePatient(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get patient by email address
// (GET /patients/lookup/by-email)
func (_ Unimplemented) GetPatientByEmail(w http.ResponseWriter, r *http.Request, params GetPatientByEmailParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get patient by ID
// (GET /patients/{patientId})
func (_ Unimplemented) GetPatientById(w http.ResponseWriter, r *http.Request, patientId PatientId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get patient's calendar view
// (GET /patients/{patientId}/calendar)
func (_ Unimplemented) GetPatientCalendar(w http.ResponseWriter, r *http.Request, patientId PatientId, params GetPatientCalendarParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// CreatePatient operation middleware
func (siw *ServerInterfaceWrapper) CreatePatient(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePatient(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPatientByEmail operation middleware
func (siw *ServerInterfaceWrapper) GetPatientByEmail(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPatientByEmailParams

	// ------------- Required query parameter "email" -------------

	if paramValue := r.URL.Query().Get("email"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "email"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "email", r.URL.Query(), &params.Email)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "email", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPatientByEmail(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPatientById operation middleware
func (siw *ServerInterfaceWrapper) GetPatientById(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "patientId" -------------
	var patientId PatientId

	err = runtime.BindStyledParameterWithOptions("simple", "patientId", chi.URLParam(r, "patientId"), &patientId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "patientId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPatientById(w, r, patientId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPatientCalendar operation middleware
func (siw *ServerInterfaceWrapper) GetPatientCalendar(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "patientId" -------------
	var patientId PatientId

	err = runtime.BindStyledParameterWithOptions("simple", "patientId", chi.URLParam(r, "patientId"), &patientId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "patientId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPatientCalendarParams

	// ------------- Required query parameter "from" -------------

	if paramValue := r.URL.Query().Get("from"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "from"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "from", r.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from", Err: err})
		return
	}

	// ------------- Required query parameter "to" -------------

	if paramValue := r.URL.Query().Get("to"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "to"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "to", r.URL.Query(), &params.To)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "to", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPatientCalendar(w, r, patientId, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/patients", wrapper.CreatePatient)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/patients/lookup/by-email", wrapper.GetPatientByEmail)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/patients/{patientId}", wrapper.GetPatientById)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/patients/{patientId}/calendar", wrapper.GetPatientCalendar)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/70fefDsIAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
