// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for AppointmentDecisionAction.
const (
	Accept AppointmentDecisionAction = "accept"
	Reject AppointmentDecisionAction = "reject"
)

// Defines values for AppointmentStatus.
const (
	Cancelled AppointmentStatus = "cancelled"
	Completed AppointmentStatus = "completed"
	Denied    AppointmentStatus = "denied"
	Requested AppointmentStatus = "requested"
	Scheduled AppointmentStatus = "scheduled"
)

// Defines values for AppointmentType.
const (
	RegularCheck AppointmentType = "regular_check"
)

// Defines values for DoctorRole.
const (
	DoctorRoleDoctor DoctorRole = "doctor"
)

// Defines values for PatientRole.
const (
	PatientRolePatient PatientRole = "patient"
)

// Defines values for SpecializationEnum.
const (
	Cardiologist        SpecializationEnum = "cardiologist"
	Dermatologist       SpecializationEnum = "dermatologist"
	Diagnostician       SpecializationEnum = "diagnostician"
	Endocrinologist     SpecializationEnum = "endocrinologist"
	Gastroenterologist  SpecializationEnum = "gastroenterologist"
	GeneralPractitioner SpecializationEnum = "general_practitioner"
	Neurologist         SpecializationEnum = "neurologist"
	Oncologist          SpecializationEnum = "oncologist"
	Orthopedist         SpecializationEnum = "orthopedist"
	Other               SpecializationEnum = "other"
	Pediatrician        SpecializationEnum = "pediatrician"
	Psychiatrist        SpecializationEnum = "psychiatrist"
	Radiologist         SpecializationEnum = "radiologist"
	Surgeon             SpecializationEnum = "surgeon"
	Urologist           SpecializationEnum = "urologist"
)

// Defines values for UserRole.
const (
	UserRoleDoctor  UserRole = "doctor"
	UserRolePatient UserRole = "patient"
)

// AppointmentBase Contains basic information about an appointment, common to all views.
type AppointmentBase struct {
	AppointmentDateTime time.Time `json:"appointmentDateTime"`
	CanceledBy          *UserRole `json:"canceledBy,omitempty"`
	CancellationReason  *string   `json:"cancellationReason,omitempty"`

	// Condition Basic info about a patient's condition (likely enriched).
	Condition     *ConditionDisplay      `json:"condition,omitempty"`
	DenialReason  *string                `json:"denialReason,omitempty"`
	Id            *openapi_types.UUID    `json:"id,omitempty"`
	Prescriptions *[]PrescriptionDisplay `json:"prescriptions,omitempty"`
	Reason        *string                `json:"reason,omitempty"`

	// Status The current status of the appointment.
	Status AppointmentStatus `json:"status"`

	// Type The type of the appointment.
	Type AppointmentType `json:"type"`
}

// AppointmentCancellation defines model for AppointmentCancellation.
type AppointmentCancellation struct {
	By UserRole `json:"by"`

	// Reason Reason for cancelling the appointment.
	Reason string `json:"reason"`
}

// AppointmentDecision Data required for staff to accept or reject an appointment request.
type AppointmentDecision struct {
	Action AppointmentDecisionAction `json:"action"`

	// Equipment List of equipment IDs to reserve if accepting.
	Equipment *[]Equipment `json:"equipment,omitempty"`

	// Facilities List of facility IDs to reserve if accepting.
	Facilities *[]Facility `json:"facilities,omitempty"`

	// Medicine List of medicine IDs to reserve if accepting.
	Medicine *[]Medicine `json:"medicine,omitempty"`

	// Reason Reason for rejecting the appointment (required if action is 'reject').
	Reason *string `json:"reason,omitempty"`
}

// AppointmentDecisionAction defines model for AppointmentDecision.Action.
type AppointmentDecisionAction string

// AppointmentReschedule defines model for AppointmentReschedule.
type AppointmentReschedule struct {
	NewAppointmentDateTime time.Time `json:"newAppointmentDateTime"`

	// Reason Reason for rescheduling the appointment.
	Reason *string `json:"reason,omitempty"`
}

// AppointmentStatus The current status of the appointment.
type AppointmentStatus string

// AppointmentType The type of the appointment.
type AppointmentType string

// ConditionDisplay Basic info about a patient's condition (likely enriched).
type ConditionDisplay struct {
	Id   openapi_types.UUID `json:"id"`
	Name string             `json:"name"`
}

// Doctor Basic doctor details including specialization (likely enriched).
type Doctor struct {
	Email     openapi_types.Email `json:"email"`
	FirstName string              `json:"firstName"`
	Id        openapi_types.UUID  `json:"id"`
	LastName  string              `json:"lastName"`
	Role      *DoctorRole         `json:"role,omitempty"`

	// Specialization Medical specialization of a doctor.
	Specialization SpecializationEnum `json:"specialization"`
}

// DoctorRole defines model for Doctor.Role.
type DoctorRole string

// DoctorAppointment defines model for DoctorAppointment.
type DoctorAppointment struct {
	AppointmentDateTime time.Time `json:"appointmentDateTime"`
	CanceledBy          *UserRole `json:"canceledBy,omitempty"`
	CancellationReason  *string   `json:"cancellationReason,omitempty"`

	// Condition Basic info about a patient's condition (likely enriched).
	Condition    *ConditionDisplay   `json:"condition,omitempty"`
	DenialReason *string             `json:"denialReason,omitempty"`
	Equipment    *[]Equipment        `json:"equipment,omitempty"`
	Facilities   *[]Facility         `json:"facilities,omitempty"`
	Id           *openapi_types.UUID `json:"id,omitempty"`
	Medicine     *[]Medicine         `json:"medicine,omitempty"`

	// Patient Basic patient details (likely enriched).
	Patient       Patient                `json:"patient"`
	Prescriptions *[]PrescriptionDisplay `json:"prescriptions,omitempty"`
	Reason        *string                `json:"reason,omitempty"`

	// Status The current status of the appointment.
	Status AppointmentStatus `json:"status"`

	// Type The type of the appointment.
	Type AppointmentType `json:"type"`
}

// Equipment Basic equipment details (likely enriched).
type Equipment struct {
	Id   openapi_types.UUID `json:"id"`
	Name string             `json:"name"`
}

// ErrorDetail Standardized error details (RFC 9457).
type ErrorDetail struct {
	Code                 string                 `json:"code"`
	Detail               string                 `json:"detail"`
	Status               int                    `json:"status"`
	Title                string                 `json:"title"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Facility Basic facility details (likely enriched).
type Facility struct {
	Id   openapi_types.UUID `json:"id"`
	Name string             `json:"name"`
}

// Medicine Basic medicine details (likely enriched).
type Medicine struct {
	Id   openapi_types.UUID `json:"id"`
	Name string             `json:"name"`
}

// NewAppointmentRequest defines model for NewAppointmentRequest.
type NewAppointmentRequest struct {
	AppointmentDateTime time.Time           `json:"appointmentDateTime"`
	ConditionId         *openapi_types.UUID `json:"conditionId,omitempty"`
	DoctorId            openapi_types.UUID  `json:"doctorId"`
	PatientId           openapi_types.UUID  `json:"patientId"`

	// Reason Reason provided by the patient for the appointment request.
	Reason *string `json:"reason,omitempty"`

	// Type The type of the appointment.
	Type AppointmentType `json:"type"`
}

// Patient Basic patient details (likely enriched).
type Patient struct {
	Email     openapi_types.Email `json:"email"`
	FirstName string              `json:"firstName"`
	Id        openapi_types.UUID  `json:"id"`
	LastName  string              `json:"lastName"`
	Role      *PatientRole        `json:"role,omitempty"`
}

// PatientRole defines model for Patient.Role.
type PatientRole string

// PatientAppointment defines model for PatientAppointment.
type PatientAppointment struct {
	AppointmentDateTime time.Time `json:"appointmentDateTime"`
	CanceledBy          *UserRole `json:"canceledBy,omitempty"`
	CancellationReason  *string   `json:"cancellationReason,omitempty"`

	// Condition Basic info about a patient's condition (likely enriched).
	Condition    *ConditionDisplay `json:"condition,omitempty"`
	DenialReason *string           `json:"denialReason,omitempty"`

	// Doctor Basic doctor details including specialization (likely enriched).
	Doctor        Doctor                 `json:"doctor"`
	Id            *openapi_types.UUID    `json:"id,omitempty"`
	Prescriptions *[]PrescriptionDisplay `json:"prescriptions,omitempty"`
	Reason        *string                `json:"reason,omitempty"`

	// Status The current status of the appointment.
	Status AppointmentStatus `json:"status"`

	// Type The type of the appointment.
	Type AppointmentType `json:"type"`
}

// PrescriptionDisplay Basic info about a patient's prescription (likely enriched).
type PrescriptionDisplay struct {
	Id   openapi_types.UUID `json:"id"`
	Name string             `json:"name"`
}

// SpecializationEnum Medical specialization of a doctor.
type SpecializationEnum string

// UserRole defines model for UserRole.
type UserRole string

// AppointmentId defines model for appointmentId.
type AppointmentId = openapi_types.UUID

// DoctorId defines model for doctorId.
type DoctorId = openapi_types.UUID

// PatientId defines model for patientId.
type PatientId = openapi_types.UUID

// QueryDate defines model for queryDate.
type QueryDate = openapi_types.Date

// QueryFrom defines model for queryFrom.
type QueryFrom = openapi_types.Date

// QueryStatus The current status of the appointment.
type QueryStatus = AppointmentStatus

// QueryTo defines model for queryTo.
type QueryTo = openapi_types.Date

// DoctorAppointmentsResponse defines model for DoctorAppointmentsResponse.
type DoctorAppointmentsResponse struct {
	Appointments []DoctorAppointment `json:"appointments"`
}

// InternalServerErrorResponse Standardized error details (RFC 9457).
type InternalServerErrorResponse = ErrorDetail

// PatientAppointmentsResponse defines model for PatientAppointmentsResponse.
type PatientAppointmentsResponse struct {
	Appointments []PatientAppointment `json:"appointments"`
}

// GetDoctorAppointmentsParams defines parameters for GetDoctorAppointments.
type GetDoctorAppointmentsParams struct {
	// Date Filter appointments for a specific date (YYYY-MM-DD format). Mutually exclusive with 'from'/'to'.
	Date *QueryDate `form:"date,omitempty" json:"date,omitempty"`

	// From The start date (inclusive, YYYY-MM-DD format) for filtering appointments. Use with 'to' for a range.
	From *QueryFrom `form:"from,omitempty" json:"from,omitempty"`

	// To The end date (inclusive, YYYY-MM-DD format) for filtering appointments. Use with 'from' for a range.
	To *QueryTo `form:"to,omitempty" json:"to,omitempty"`

	// Status Filter appointments by status.
	Status *QueryStatus `form:"status,omitempty" json:"status,omitempty"`
}

// GetPatientAppointmentsParams defines parameters for GetPatientAppointments.
type GetPatientAppointmentsParams struct {
	// From The start date (inclusive, YYYY-MM-DD format) for filtering appointments. Use with 'to' for a range.
	From *QueryFrom `form:"from,omitempty" json:"from,omitempty"`

	// To The end date (inclusive, YYYY-MM-DD format) for filtering appointments. Use with 'from' for a range.
	To *QueryTo `form:"to,omitempty" json:"to,omitempty"`

	// Status Filter appointments by status.
	Status *QueryStatus `form:"status,omitempty" json:"status,omitempty"`
}

// RequestAppointmentJSONRequestBody defines body for RequestAppointment for application/json ContentType.
type RequestAppointmentJSONRequestBody = NewAppointmentRequest

// CancelAppointmentJSONRequestBody defines body for CancelAppointment for application/json ContentType.
type CancelAppointmentJSONRequestBody = AppointmentCancellation

// RescheduleAppointmentJSONRequestBody defines body for RescheduleAppointment for application/json ContentType.
type RescheduleAppointmentJSONRequestBody = AppointmentReschedule

// DecideAppointmentJSONRequestBody defines body for DecideAppointment for application/json ContentType.
type DecideAppointmentJSONRequestBody = AppointmentDecision

// Getter for additional properties for ErrorDetail. Returns the specified
// element and whether it was found
func (a ErrorDetail) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ErrorDetail
func (a *ErrorDetail) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ErrorDetail to handle AdditionalProperties
func (a *ErrorDetail) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["code"]; found {
		err = json.Unmarshal(raw, &a.Code)
		if err != nil {
			return fmt.Errorf("error reading 'code': %w", err)
		}
		delete(object, "code")
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &a.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
		delete(object, "detail")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ErrorDetail to handle AdditionalProperties
func (a ErrorDetail) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["code"], err = json.Marshal(a.Code)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'code': %w", err)
	}

	object["detail"], err = json.Marshal(a.Detail)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'detail': %w", err)
	}

	object["status"], err = json.Marshal(a.Status)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'status': %w", err)
	}

	object["title"], err = json.Marshal(a.Title)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'title': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Patient creates an appointment request
	// (POST /appointments)
	RequestAppointment(w http.ResponseWriter, r *http.Request)
	// Cancel an appointment
	// (DELETE /appointments/{appointmentId})
	CancelAppointment(w http.ResponseWriter, r *http.Request, appointmentId AppointmentId)
	// Reschedule an appointment
	// (PATCH /appointments/{appointmentId})
	RescheduleAppointment(w http.ResponseWriter, r *http.Request, appointmentId AppointmentId)
	// Decide appointment's status
	// (POST /appointments/{appointmentId})
	DecideAppointment(w http.ResponseWriter, r *http.Request, appointmentId AppointmentId)
	// Get specific appointment scheduled to a doctor (Doctor View)
	// (GET /doctors/{doctorId}/appointment/{appointmentId})
	GetDoctorAppointmentById(w http.ResponseWriter, r *http.Request, doctorId DoctorId, appointmentId AppointmentId)
	// Get appointments for a doctor, optionally filtered by date or date range (Doctor View)
	// (GET /doctors/{doctorId}/appointments)
	GetDoctorAppointments(w http.ResponseWriter, r *http.Request, doctorId DoctorId, params GetDoctorAppointmentsParams)
	// Get specific appointment scheduled by patient (Patient View)
	// (GET /patients/{patientId}/appointment/{appointmentId})
	GetPatientAppointmentById(w http.ResponseWriter, r *http.Request, patientId PatientId, appointmentId AppointmentId)
	// Get all appointments for a patient (Patient View)
	// (GET /patients/{patientId}/appointments)
	GetPatientAppointments(w http.ResponseWriter, r *http.Request, patientId PatientId, params GetPatientAppointmentsParams)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Patient creates an appointment request
// (POST /appointments)
func (_ Unimplemented) RequestAppointment(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Cancel an appointment
// (DELETE /appointments/{appointmentId})
func (_ Unimplemented) CancelAppointment(w http.ResponseWriter, r *http.Request, appointmentId AppointmentId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Reschedule an appointment
// (PATCH /appointments/{appointmentId})
func (_ Unimplemented) RescheduleAppointment(w http.ResponseWriter, r *http.Request, appointmentId AppointmentId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Decide appointment's status
// (POST /appointments/{appointmentId})
func (_ Unimplemented) DecideAppointment(w http.ResponseWriter, r *http.Request, appointmentId AppointmentId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get specific appointment scheduled to a doctor (Doctor View)
// (GET /doctors/{doctorId}/appointment/{appointmentId})
func (_ Unimplemented) GetDoctorAppointmentById(w http.ResponseWriter, r *http.Request, doctorId DoctorId, appointmentId AppointmentId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get appointments for a doctor, optionally filtered by date or date range (Doctor View)
// (GET /doctors/{doctorId}/appointments)
func (_ Unimplemented) GetDoctorAppointments(w http.ResponseWriter, r *http.Request, doctorId DoctorId, params GetDoctorAppointmentsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get specific appointment scheduled by patient (Patient View)
// (GET /patients/{patientId}/appointment/{appointmentId})
func (_ Unimplemented) GetPatientAppointmentById(w http.ResponseWriter, r *http.Request, patientId PatientId, appointmentId AppointmentId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get all appointments for a patient (Patient View)
// (GET /patients/{patientId}/appointments)
func (_ Unimplemented) GetPatientAppointments(w http.ResponseWriter, r *http.Request, patientId PatientId, params GetPatientAppointmentsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// RequestAppointment operation middleware
func (siw *ServerInterfaceWrapper) RequestAppointment(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RequestAppointment(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CancelAppointment operation middleware
func (siw *ServerInterfaceWrapper) CancelAppointment(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "appointmentId" -------------
	var appointmentId AppointmentId

	err = runtime.BindStyledParameterWithOptions("simple", "appointmentId", chi.URLParam(r, "appointmentId"), &appointmentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "appointmentId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CancelAppointment(w, r, appointmentId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// RescheduleAppointment operation middleware
func (siw *ServerInterfaceWrapper) RescheduleAppointment(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "appointmentId" -------------
	var appointmentId AppointmentId

	err = runtime.BindStyledParameterWithOptions("simple", "appointmentId", chi.URLParam(r, "appointmentId"), &appointmentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "appointmentId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RescheduleAppointment(w, r, appointmentId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DecideAppointment operation middleware
func (siw *ServerInterfaceWrapper) DecideAppointment(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "appointmentId" -------------
	var appointmentId AppointmentId

	err = runtime.BindStyledParameterWithOptions("simple", "appointmentId", chi.URLParam(r, "appointmentId"), &appointmentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "appointmentId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DecideAppointment(w, r, appointmentId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDoctorAppointmentById operation middleware
func (siw *ServerInterfaceWrapper) GetDoctorAppointmentById(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "doctorId" -------------
	var doctorId DoctorId

	err = runtime.BindStyledParameterWithOptions("simple", "doctorId", chi.URLParam(r, "doctorId"), &doctorId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "doctorId", Err: err})
		return
	}

	// ------------- Path parameter "appointmentId" -------------
	var appointmentId AppointmentId

	err = runtime.BindStyledParameterWithOptions("simple", "appointmentId", chi.URLParam(r, "appointmentId"), &appointmentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "appointmentId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDoctorAppointmentById(w, r, doctorId, appointmentId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDoctorAppointments operation middleware
func (siw *ServerInterfaceWrapper) GetDoctorAppointments(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "doctorId" -------------
	var doctorId DoctorId

	err = runtime.BindStyledParameterWithOptions("simple", "doctorId", chi.URLParam(r, "doctorId"), &doctorId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "doctorId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDoctorAppointmentsParams

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", r.URL.Query(), &params.Date)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date", Err: err})
		return
	}

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", r.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from", Err: err})
		return
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", r.URL.Query(), &params.To)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "to", Err: err})
		return
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDoctorAppointments(w, r, doctorId, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPatientAppointmentById operation middleware
func (siw *ServerInterfaceWrapper) GetPatientAppointmentById(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "patientId" -------------
	var patientId PatientId

	err = runtime.BindStyledParameterWithOptions("simple", "patientId", chi.URLParam(r, "patientId"), &patientId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "patientId", Err: err})
		return
	}

	// ------------- Path parameter "appointmentId" -------------
	var appointmentId AppointmentId

	err = runtime.BindStyledParameterWithOptions("simple", "appointmentId", chi.URLParam(r, "appointmentId"), &appointmentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "appointmentId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPatientAppointmentById(w, r, patientId, appointmentId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPatientAppointments operation middleware
func (siw *ServerInterfaceWrapper) GetPatientAppointments(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "patientId" -------------
	var patientId PatientId

	err = runtime.BindStyledParameterWithOptions("simple", "patientId", chi.URLParam(r, "patientId"), &patientId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "patientId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPatientAppointmentsParams

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", r.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from", Err: err})
		return
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", r.URL.Query(), &params.To)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "to", Err: err})
		return
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPatientAppointments(w, r, patientId, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/appointments", wrapper.RequestAppointment)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/appointments/{appointmentId}", wrapper.CancelAppointment)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/appointments/{appointmentId}", wrapper.RescheduleAppointment)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/appointments/{appointmentId}", wrapper.DecideAppointment)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/doctors/{doctorId}/appointment/{appointmentId}", wrapper.GetDoctorAppointmentById)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/doctors/{doctorId}/appointments", wrapper.GetDoctorAppointments)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/patients/{patientId}/appointment/{appointmentId}", wrapper.GetPatientAppointmentById)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/patients/{patientId}/appointments", wrapper.GetPatientAppointments)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
